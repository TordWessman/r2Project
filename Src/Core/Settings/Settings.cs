// This file is part of r2Poject.
//
// Copyright 2016 Tord Wessman
// 
// r2Project is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// r2Project is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with r2Project. If not, see <http://www.gnu.org/licenses/>.
// 

ï»¿/**
*
*
*	This is an autogenerated file. DO NOT EDIT!
*
*	Compiled for Unix 3.19.0.28
*/
using System;
using System.IO;
using System.Xml;
using System.Collections.Generic;
using Core.Device;

namespace Core
{
	public class Settings : DeviceBase
	{
		public static readonly string SETTINGS_DEVICE_ID = "settings";
		private string m_basePath;
		private static Settings m_instance;

		private static readonly object m_lock = new object();

		private Dictionary<string,dynamic> m_constants;
		private static readonly object m_instanceLock = new object ();
		private static readonly object m_dataLoadLock = new object ();
		private IList<string> m_dataLoaded;

		private Settings () : base(SETTINGS_DEVICE_ID)
		{
			ReloadConstants ();
		}

		/// <summary>
		///	Compile time generated Path information.
		/// </summary>
		public readonly ConstsClass C = new ConstsClass();

		/// <summary>
		///	Compile time generated Path information.
		/// </summary>
		public static ConstsClass Consts {get{
			return Settings.Instance.C;
		}}

		/// <summary>
		///	Compile time generated Path information.
		/// </summary>
		public readonly PathsClass P = new PathsClass();

		/// <summary>
		///	Compile time generated Path information.
		/// </summary>
		public static PathsClass Paths {get{
			return Settings.Instance.P;
		}}

		/// <summary>
		///	Compile time generated IDevice identifiers.
		/// </summary>
		public readonly IdentifiersClass I = new IdentifiersClass();

		/// <summary>
		///	Compile time generated IDevice identifiers.
		/// </summary>
		public static IdentifiersClass Identifiers { get {
			return Settings.Instance.I;
		}}

		/// <summary>
		///	Application base path. Traversing directories and looking for "Core.config" to locate application root.
		/// </summary>
		public static string BasePath {
			get {

				lock(m_lock) {

					if (Settings.Instance.m_basePath == null) {

						Settings.Instance.m_basePath = System.IO.Directory.GetCurrentDirectory();
						string configFullPath = "";

						for (int i = 0; i < 20; i++) {

							configFullPath = Settings.Instance.m_basePath + System.IO.Path.DirectorySeparatorChar + "Core.config";

							if (System.IO.File.Exists (configFullPath)) {
								break;
							} else {
								Settings.Instance.m_basePath =  System.IO.Directory.GetParent (Settings.Instance.m_basePath).FullName;
							}

						}
					}
				}

				return m_instance.m_basePath;
			}
		}

		/// <summary>
		/// Returns a static instance of the settings. Creates an instance if needed.
		/// </summary>
		/// <value>The instance.</value>
		public static Settings Instance {
			get {
				lock (m_instanceLock) {
					if (Settings.m_instance == null) {
						Settings.m_instance = new Settings ();
					}

					return m_instance;
				}
			}
		}


		/// <summary>
		/// Resets configuration settings for constants and forces them to be reloaded (lazily).
		/// </summary>
		public void ReloadConstants() {
			m_constants = new Dictionary<string,dynamic> ();
			m_dataLoaded = new List<string> ();
		}

		/// <summary>
		/// Adds a value to the Const dictionary.
		/// </summary>
		/// <param name="key">Key.</param>
		/// <param name="value">Value.</param>
		protected void AddConstant(string key, dynamic value) {

			key = key.ToLower ();

			if (m_constants.ContainsKey (key)) {
				//TODO: print error
			} else {

				m_constants.Add (key, value);
			}

		}

		/// <summary>
		/// Checks if the data for key have been loaded and loads the data at runtime if required.
		/// </summary>
		/// <param name="key">Key.</param>
		/// <param name="configFileName">Config file name.</param>
		public void CheckAndLoadData(string key, string configFileName) {

			lock (m_dataLoadLock) {

				if (!Settings.Instance.m_dataLoaded.Contains (key)) {
					Settings.LoadConstData (configFileName);

					Settings.Instance.m_dataLoaded.Add (key);
				}
			}
		}

		/// <summary>
		/// Returns a value of a dynamic type.
		/// </summary>
		/// <returns>The value.</returns>
		/// <param name="key">Key.</param>
		public dynamic Val(string key) {

			key = key.ToLower ();
			if (Settings.Instance.m_constants.ContainsKey (key)) {
				return Settings.Instance.m_constants [key];
			}

			throw new ApplicationException ("Value not found in Settings: " + key);

		}

		/// <summary>
		/// Returns a value of type T using key or the default value for T
		/// </summary>
		/// <returns>The value.</returns>
		/// <param name="key">Key.</param>
		/// <typeparam name="T">The 1st type parameter.</typeparam>
		public T GetValue<T>(string key) {

			key = key.ToLower ();

			if (Settings.Instance.m_constants.ContainsKey (key)) {
				return (T) Settings.Instance.m_constants [key];
			}

			return default(T);

		} 

		/// <summary>
		/// Loads and returns an XmlDocument.
		/// </summary>
		/// <returns>The config xml.</returns>
		/// <param name="file">File.</param>
		private static XmlDocument GetConfigXml(string file) {

			XmlDocument doc = new XmlDocument();
			doc.PreserveWhitespace = false;
			try { doc.Load(file); }
			catch (System.IO.FileNotFoundException)
			{}

			return doc;
		}

		/// <summary>
		/// Loads configuration file data from parameter
		/// </summary>
		/// <param name="configFileName">Config file name.</param>
		public static void LoadConstData(string configFileName) {

			string fileName = Settings.BasePath + configFileName;

			foreach (XmlNode pathsNode in GetConfigXml(fileName).SelectNodes("/Configuration/Consts")) {
				foreach (XmlNode node in pathsNode.ChildNodes) { 
					if (!((node.Attributes["ignore"] != null && node.Attributes["ignore"].Value == "true"))) {

						Settings.Instance.AddConstant (node.Name, node.Attributes["type"] != null ? ParseType(node.Attributes["type"].Value, node.InnerText) : node.InnerText  );
					}
				}

			}
		}

		/// <summary>
		/// Returns a dynamic parsing of value using description as type identifier.
		/// </summary>
		/// <returns>The type.</returns>
		/// <param name="description">Description.</param>
		/// <param name="value">Value.</param>
		public static dynamic ParseType(string description, string value) {
			switch (description) {
			case "int":
				return int.Parse (value);
			default:
				return typeof(string);
			}
		}

		public  class PathsClass {

			///<summary>
			///Resource base path.
			///</summary>
			public string Resources (string fileName = null) {

				if (fileName == null) {
					return Settings.BasePath + "/Resources";
				}
				return Settings.BasePath + "/Resources" + System.IO.Path.DirectorySeparatorChar + fileName;
			}

			///<summary>
			///contains various types of runtime scripts
			///</summary>
			public string Scripts (string fileName = null) {

				if (fileName == null) {
					return Settings.BasePath + "/Resources/Scripts";
				}
				return Settings.BasePath + "/Resources/Scripts" + System.IO.Path.DirectorySeparatorChar + fileName;
			}

			///<summary>
			///Here be all Ruby script files.
			///</summary>
			public string Ruby (string fileName = null) {

				if (fileName == null) {
					return Settings.BasePath + "/Resources/Scripts/Ruby";
				}
				return Settings.BasePath + "/Resources/Scripts/Ruby" + System.IO.Path.DirectorySeparatorChar + fileName;
			}

			public string Shell (string fileName = null) {

				if (fileName == null) {
					return Settings.BasePath + "/Resources/Scripts/Shell";
				}
				return Settings.BasePath + "/Resources/Scripts/Shell" + System.IO.Path.DirectorySeparatorChar + fileName;
			}

			public string lib (string fileName = null) {

				if (fileName == null) {
					return Settings.BasePath + "/Resources/Scripts/Sphinx/lib";
				}
				return Settings.BasePath + "/Resources/Scripts/Sphinx/lib" + System.IO.Path.DirectorySeparatorChar + fileName;
			}

			public string MakeDict (string fileName = null) {

				if (fileName == null) {
					return Settings.BasePath + "/Resources/Scripts/Sphinx/MakeDict";
				}
				return Settings.BasePath + "/Resources/Scripts/Sphinx/MakeDict" + System.IO.Path.DirectorySeparatorChar + fileName;
			}

			///<summary>
			///contains all database files for the clients
			///</summary>
			public string Databases (string fileName = null) {

				if (fileName == null) {
					return Settings.BasePath + "/Resources/Databases";
				}
				return Settings.BasePath + "/Resources/Databases" + System.IO.Path.DirectorySeparatorChar + fileName;
			}

			public string Audio (string fileName = null) {

				if (fileName == null) {
					return Settings.BasePath + "/Resources/Audio";
				}
				return Settings.BasePath + "/Resources/Audio" + System.IO.Path.DirectorySeparatorChar + fileName;
			}

			///<summary>
			///contains ceritificates used for push notifications.
			///</summary>
			public string Cert (string fileName = null) {

				if (fileName == null) {
					return Settings.BasePath + "/Resources/Cert";
				}
				return Settings.BasePath + "/Resources/Cert" + System.IO.Path.DirectorySeparatorChar + fileName;
			}

			public string Language (string fileName = null) {

				if (fileName == null) {
					return Settings.BasePath + "/Resources/Language";
				}
				return Settings.BasePath + "/Resources/Language" + System.IO.Path.DirectorySeparatorChar + fileName;
			}

			public string hub4wsj_sc_8k (string fileName = null) {

				if (fileName == null) {
					return Settings.BasePath + "/Resources/Language/hub4wsj_sc_8k";
				}
				return Settings.BasePath + "/Resources/Language/hub4wsj_sc_8k" + System.IO.Path.DirectorySeparatorChar + fileName;
			}

			public string chomskyAIML (string fileName = null) {

				if (fileName == null) {
					return Settings.BasePath + "/Resources/Language/chomskyAIML";
				}
				return Settings.BasePath + "/Resources/Language/chomskyAIML" + System.IO.Path.DirectorySeparatorChar + fileName;
			}

			public string chatbot (string fileName = null) {

				if (fileName == null) {
					return Settings.BasePath + "/Resources/Language/chatbot";
				}
				return Settings.BasePath + "/Resources/Language/chatbot" + System.IO.Path.DirectorySeparatorChar + fileName;
			}

			public string aimlConfig (string fileName = null) {

				if (fileName == null) {
					return Settings.BasePath + "/Resources/Language/aimlConfig";
				}
				return Settings.BasePath + "/Resources/Language/aimlConfig" + System.IO.Path.DirectorySeparatorChar + fileName;
			}

			public string Vision (string fileName = null) {

				if (fileName == null) {
					return Settings.BasePath + "/Resources/Vision";
				}
				return Settings.BasePath + "/Resources/Vision" + System.IO.Path.DirectorySeparatorChar + fileName;
			}

			public string face (string fileName = null) {

				if (fileName == null) {
					return Settings.BasePath + "/Resources/Vision/face";
				}
				return Settings.BasePath + "/Resources/Vision/face" + System.IO.Path.DirectorySeparatorChar + fileName;
			}

			public string haar (string fileName = null) {

				if (fileName == null) {
					return Settings.BasePath + "/Resources/Vision/haar";
				}
				return Settings.BasePath + "/Resources/Vision/haar" + System.IO.Path.DirectorySeparatorChar + fileName;
			}

			public string model (string fileName = null) {

				if (fileName == null) {
					return Settings.BasePath + "/Resources/Vision/model";
				}
				return Settings.BasePath + "/Resources/Vision/model" + System.IO.Path.DirectorySeparatorChar + fileName;
			}

			///<summary>
			///contains dynamic, native libraries
			///</summary>
			public string Lib (string fileName = null) {

				if (fileName == null) {
					return Settings.BasePath + "/Lib";
				}
				return Settings.BasePath + "/Lib" + System.IO.Path.DirectorySeparatorChar + fileName;
			}


		}


		public  class IdentifiersClass {

			///<summary>
			///Host manager. Keep tracks of/receive hello packages from remote hosts and broadcasts existance.
			///</summary>
			public  string HostManager () {
				return  "hostmgr";
			}

			public  string Server () {
				return  "server";
			}

			///<summary>
			///Responsible for creating new (iron) scripts
			///</summary>
			public  string ScriptFactory () {
				return  "script_factory";
			}

			///<summary>
			///Interface for retrieving memories
			///</summary>
			public  string Memory () {
				return  "memory";
			}

			///<summary>
			///communicates memories
			///</summary>
			public  string MemoryBus () {
				return  "membus";
			}

			public  string Serializer () {
				return  "serializer";
			}

			///<summary>
			///default factory instance for general devices
			///</summary>
			public  string DeviceFactory () {
				return  "device_factory";
			}

			///<summary>
			///the id of the script running the show
			///</summary>
			public  string RunLoopScriptId () {
				return  "main";
			}

			///<summary>
			///keeps track of all running processes
			///</summary>
			public  string TaskMonitor () {
				return  "task_monitor";
			}


		}


		public  class ConstsClass {

			///<summary>
			///Just a number.
			///</summary>
			public int Number () {
				Settings.Instance.CheckAndLoadData ("Core", "/Core.config");
				return  Settings.Instance.GetValue<int> ("Number");
			}


		}


	}
}