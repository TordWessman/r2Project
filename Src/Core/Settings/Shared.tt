<#@ template language="C#"  hostspecific="true" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.IO" #>
<#
	// Configuration path position in array
	int CPATH = 0;

	// Configuration file name position in array
	int CFILE = 1;

	string baseConfigFileName = "Core";
#>
/**
*
*
*	This is an autogenerated file. DO NOT EDIT!
*
*	Compiled for <#=Environment.OSVersion.ToString()#> at <#=DateTime.Now#>
*/
<#+

	public string GetCurrentDirectory() {

		return  Path.GetDirectoryName(Host.TemplateFile); 
	
	}

	public XmlDocument GetConfigXml(string file) {
		
		XmlDocument doc = new XmlDocument();
		doc.PreserveWhitespace = false;
	
		try { doc.Load(file); }
		catch (System.IO.FileNotFoundException) {}
 			
 		return doc;
	
	}


	// returns [0] the base path of the specified file and [1] the full path of the file, including name
	public string[] GetConfig(string configFileName, int maxIterations = 20) {

		// Fetch project base path:
		configFileName += ".config";

		string baseDir = GetCurrentDirectory(); 
		string configFullPath = "";

		for (int i = 0; i < maxIterations; i++) {

			configFullPath = baseDir + Path.DirectorySeparatorChar + configFileName;

			if (File.Exists(configFullPath)) {
	
				#><#="\n// --- Using configuration file: " + configFullPath + " ---\n" #><#+
				break;
	
			} else {
	
				if ( Directory.GetParent(baseDir) != null) {
	
					baseDir =  Directory.GetParent(baseDir).FullName;

				} else {
	
					return new string []{};
	
				}

			}
				
		}

		return new string[] {baseDir, configFullPath};

	}

	///
	/// returns the paths for an XML documents as functions using baseDir for checking path existence and isExtension to add the static directive for functions.
	///
	public string GetPathsForDoc(string name, XmlDocument doc, string baseDir, bool isExtension = false) {

		string returnString = "\t\t" + (isExtension ? "internal static" : "public") + " class Paths"  + (isExtension ? name + "Extensions" : "Class") + " {\n\n" ;

		foreach (XmlNode pathsNode in doc.SelectNodes("/Configuration/Paths")) {

			foreach (XmlNode node in pathsNode.ChildNodes) { 

				returnString += GetPaths(baseDir, "" , node, isExtension);
			}

		}

		return returnString + "\n\t\t}\n";
	}

	public string GetIdentifiersForDoc(string name, XmlDocument doc, bool isExtension = false) {

		string returnString = "\t\t" + (isExtension ? "public static" : "public") + " class Identifiers"  + (isExtension ? name + "Extensions" : "Class") + " {\n\n" ;

		foreach (XmlNode pathsNode in doc.SelectNodes("/Configuration/Identifiers")) {

			foreach (XmlNode node in pathsNode.ChildNodes) {
		
				if (!((node.Attributes["ignore"] != null && node.Attributes["ignore"].Value == "true"))) {
		
						returnString += GetCommentsSection(node);
						returnString += "\t\t\tpublic " + (isExtension ? "static" : "") + " string " + node.Name + "(" + (isExtension ? "this Settings.IdentifiersClass self" : "") + ") {\n" +
						"				return  \"" +  node.InnerText + "\";\n" +
						"			}\n\n";
		
				}
		
			}

		}

		return returnString + "\n\t\t}\n";
	}

	// returns the paths of an XML node hierarchy
	public string GetPaths(string baseDir, string path, XmlNode pathNode, bool isExtension = false) {

		string pathsString = (pathNode.Attributes["ignore"] != null && pathNode.Attributes["ignore"].Value == "true") ? "" :
			GetCommentsSection(pathNode) + GetPathVarPrint(baseDir, path, pathNode, isExtension);
		
		// The node contains the "relative" attribute and the path will be set relative to the baseDir

		if (pathNode.Attributes["relative"] != null) {
			
			path = path + Path.DirectorySeparatorChar + pathNode.Attributes["relative"].Value;
		
		} else {
			
			path = path + Path.DirectorySeparatorChar + pathNode.Name;

		}

		foreach (XmlNode node in pathNode.ChildNodes) {
	
			pathsString += GetPaths(baseDir, path, node, isExtension) + "";
	
		}

		return pathsString;
	
	}

	// returns the printout of the specified path node
	public string GetPathVarPrint(string baseDir, string path, XmlNode pathNode, bool isExtension = false) {

		string directoryPath =  path + Path.DirectorySeparatorChar + pathNode.Name;
		string absoluteDirectoryPath = baseDir + Path.DirectorySeparatorChar + directoryPath;

		// The node contains the "relative" attribute and the path will be set relative to the baseDir
		if (pathNode.Attributes["relative"] != null) {
			
			absoluteDirectoryPath = baseDir + Path.DirectorySeparatorChar + pathNode.Attributes["relative"].Value;
			directoryPath = System.IO.Path.DirectorySeparatorChar + pathNode.Attributes["relative"].Value;
		
		} else if (pathNode.Attributes["absolute"] != null) { 

			absoluteDirectoryPath = pathNode.Attributes["absolute"].Value;
			directoryPath = pathNode.Attributes["absolute"].Value;
		
		}

		if (!Directory.Exists(absoluteDirectoryPath)) {
	
			return "\t\t\t// Configuration error! Requested path: '" + absoluteDirectoryPath + "' does not exist!\n";
	
		}

		return "\t\t\t" + (isExtension ? "public static string " : "public string ") + pathNode.Name  + "(" + (isExtension ? "this Settings.PathsClass self, " : "") + "string fileName = null) {\n\n" +
"				if (fileName == null) {\n" +
"					return " + ( pathNode.Attributes["absolute"] != null ? "" : "Settings.BasePath + " ) + "\"" + directoryPath + "\";\n" +
"				}\n" +
"				return " + ( pathNode.Attributes["absolute"] != null ? "" : "Settings.BasePath + " ) + "\"" + directoryPath + "\" + System.IO.Path.DirectorySeparatorChar + fileName;\n" +
"			}\n\n";
	} 

	// Creates Const loading segment
	public string GetConstsForDoc(string name, string confFileName, XmlDocument doc, bool isExtension = false) {

		string returnString = "\t\t" + (isExtension ? "internal static" : "public") + " class Consts"  + (isExtension ? name + "Extensions" : "Class") + " {\n\n" ;

		foreach (XmlNode pathsNode in doc.SelectNodes("/Configuration/Consts")) {
	
			foreach (XmlNode node in pathsNode.ChildNodes) {

				if (!((node.Attributes["ignore"] != null && node.Attributes["ignore"].Value == "true"))) {
					string typeName = node.Attributes["type"] != null ? node.Attributes["type"].Value : "string";

					returnString += GetCommentsSection(node);

					returnString += "\t\t\t" + (isExtension ? "internal static " : "public ") + typeName +  " " + node.Name + "(" + (isExtension ? "this Settings.ConstsClass self, " : "") + typeName + " setValue = default(" + typeName + ")) {\n" +
					"				if (setValue != default(" + typeName + ")) {\n" +
					"					Settings.Instance.SetValue<" + typeName + ">(\"" + node.Name + "\", setValue);\n" +
					"				}\n\n" +
					"				Settings.Instance.CheckAndLoadData(\"" + name +"\", \"" + confFileName + "\");\n" +
					"				" + typeName + " value = Settings.Instance.GetValue<" + typeName + ">(\"" + node.Name + "\");\n" +
					"				return value;\n" +
					"			}\n\n";
			
				}

			}
		
		}

		return returnString + "\n\t\t}\n";
	
	}

	private string GetCommentsSection(XmlNode node) {

		if (node.Attributes["comment"] != null) {
	
			return "\t\t\t///<summary>\n"+
			"\t\t\t///" + node.Attributes["comment"].Value + "\n" +
			"\t\t\t///</summary>\n";
	
		}
	
		return "";
	
	}


	//Removes the basePath part of otherPath 
	public string StripBasePath(string basePath, string otherPath) {
		
		//if (basePath.Length > otherPath.Length) {
		//	return basePath + Path.DirectorySeparatorChar + otherPath;
			//throw new ApplicationException("basePath (" + basePath + ") cannot be shorter than otherPath: " + otherPath);
		//}

		if (otherPath.Length < basePath.Length || otherPath.Substring(0, basePath.Length) != basePath) {
	
			return  Path.DirectorySeparatorChar + otherPath;
			//throw new ApplicationException("basePath (" + basePath + ") is not the start of otherPath: " + otherPath);
	
		}

		return otherPath.Substring(basePath.Length);
	
	}
		
#>